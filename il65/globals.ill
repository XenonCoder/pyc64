; global definitions

.output raw

.block c64 {
		.memory SCRATCH_ZP1     $02
		.memory SCRATCH_ZP2     $03

		.memory COLOR       $286        ; cursor color

; ---- VIC-II registers ----

		.memory SP0X        $d000
		.memory SP0Y        $d001
		.memory SP1X        $d002
		.memory SP1Y        $d003
		.memory SP2X        $d004
		.memory SP2Y        $d005
		.memory SP3X        $d006
		.memory SP3Y        $d007
		.memory SP4X        $d008
		.memory SP4Y        $d009
		.memory SP5X        $d00a
		.memory SP5Y        $d00b
		.memory SP6X        $d00c
		.memory SP6Y        $d00d
		.memory SP7X        $d00e
		.memory SP7Y        $d00f

		.memory MSIGX       $d010
		.memory SCROLY      $d011
		.memory RASTER      $d012
		.memory LPENX       $d013
		.memory LPENY       $d014
		.memory SPENA       $d015
		.memory SCROLX      $d016
		.memory YXPAND      $d017
		.memory VMCSB       $d018
		.memory VICIRQ      $d019
		.memory IREQMASK    $d01a
		.memory SPBGPR      $d01b
		.memory SPMC        $d01c
		.memory XXPAND      $d01d
		.memory SPSPCL      $d01e
		.memory SPBGCL      $d01f

		.memory EXTCOL      $d020       ; border color
		.memory BGCOL0      $d021       ; screen color
		.memory BGCOL1      $d022
		.memory BGCOL2      $d023
		.memory BGCOL4      $d024
		.memory SPMC0       $d025
		.memory SPMC1       $d026
		.memory SP0COL      $d027
		.memory SP1COL      $d028
		.memory SP2COL      $d029
		.memory SP3COL      $d02a
		.memory SP4COL      $d02b
		.memory SP5COL      $d02c
		.memory SP6COL      $d02d
		.memory SP7COL      $d02e

; ---- end of VIC-II registers ----

; ---- C64 basic routines ----

.subx   CLEARSCR    () -> (A?, X?, Y?)          $E544   ; clear the screen
.subx   HOMECRSR    () -> (A?, X?, Y?)          $E566   ; cursor to top left of screen



; ---- end of C64 basic routines ----

; ---- C64 kernal routines ----

.subx   CINT     () -> (A?, X?, Y?)        $FF81    ; (alias: SCINIT) initialize screen editor and video chip
.subx   IOINIT   () -> (A?, X?)            $FF84    ; initialize I/O devices
.subx   RAMTAS   () -> (A?, X?, Y?)        $FF87    ; initialize RAM, tape buffer, screen
.subx   RESTOR   () -> ()                  $FF8A    ; restore default I/O vectors
.subx   VECTOR   (direction: SC, userptr: XY) -> (A?, Y?)    $FF8D    ; read/set I/O vector table
.subx   SETMSG   (value: A) -> ()          $FF90    ; set Kernal message control flag
.subx   SECOND   (address: A) -> (A?)      $FF93    ; (alias: LSTNSA) send secondary address after LISTEN
.subx   TKSA     (address: A) -> (A?)      $FF96    ; (alias: TALKSA) send secondary address after TALK
.subx   MEMTOP   (direction: SC, address: XY) -> (XY)    $FF99    ; read/set top of memory pointer
.subx   MEMBOT   (direction: SC, address: XY) -> (XY)    $FF9C    ; read/set bottom of memory pointer
.subx   SCNKEY   () -> (A?, X?, Y?)        $FF9F    ; scan the keyboard
.subx   SETTMO   (timeout: A) -> ()        $FFA2    ; set time-out flag for IEEE bus
.subx   ACPTR    () -> (A)                 $FFA5    ; (alias: IECIN) input byte from serial bus
.subx   CIOUT    (byte: A) -> ()           $FFA8    ; (alias: IECOUT) output byte to serial bus
.subx   UNTLK    () -> (A?)                $FFAB    ; command serial bus device to UNTALK
.subx   UNLSN    () -> (A?)                $FFAE    ; command serial bus device to UNLISTEN
.subx   LISTEN   (device: A) -> (A?)       $FFB1    ; command serial bus device to LISTEN
.subx   TALK     (device: A) -> (A?)       $FFB4    ; command serial bus device to TALK
.subx   READST   () -> (A)                 $FFB7    ; read I/O status word
.subx   SETLFS   (logical: A, device: X, address: Y) -> ()    $FFBA    ; set logical file parameters
.subx   SETNAM   (namelen: A, filename: XY) -> ()   $FFBD    ; set filename parameters
.subx   OPEN     () -> (A?, X?, Y?)        $FFC0    ; (via 794 ($31A)) open a logical file
.subx   CLOSE    (logical: A) -> (A?, X?, Y?)       $FFC3    ; (via 796 ($31C)) close a logical file
.subx   CHKIN    (logical: X) -> (A?, X?)  $FFC6    ; (via 798 ($31E)) define an input channel
.subx   CHKOUT   (logical: X) -> (A?, X?)  $FFC9    ; (via 800 ($320)) define an output channel
.subx   CLRCHN   () -> (A?, X?)            $FFCC    ; (via 802 ($322)) restore default devices
.subx   CHRIN    () -> (A, Y?)             $FFCF    ; (via 804 ($324)) input a character
.subx   CHROUT   (char: A) -> ()           $FFD2    ; (via 806 ($326)) output a character
.subx   LOAD     (verify: A, address: XY) -> (SC, A, X, Y)   $FFD5    ; (via 816 ($330)) load from device
.subx   SAVE     (zp_startaddr: A, endaddr: XY) -> (SC, A)   $FFD8    ; (via 818 ($332)) save to a device
.subx   SETTIM   (low: A, middle: X, high: Y) -> ()          $FFDB    ; set the software clock
.subx   RDTIM    () -> (A, X, Y)           $FFDE    ; read the software clock
.subx   STOP     () -> (SZ, SC, A?, X?)    $FFE1    ; (via 808 ($328)) check the STOP key
.subx   GETIN    () -> (A, X?, Y?)         $FFE4    ; (via 810 ($32A)) get a character
.subx   CLALL    () -> (A?, X?)            $FFE7    ; (via 812 ($32C)) close all files
.subx   UDTIM    () -> (A?, X?)            $FFEA    ; update the software clock
.subx   SCREEN   () -> (X, Y)              $FFED    ; read number of screen rows and columns
.subx   PLOT     (direction: SC, column: X, row: Y) -> (X, Y)    $FFF0    ; read/set position of cursor on screen
.subx   IOBASE   () -> (X, Y)              $FFF3    ; read base address of I/O devices

; ---- end of C64 kernal routines ----

		.memory .word NMI_VEC   $FFFA
		.memory .word RESET_VEC $FFFC
		.memory .word IRQ_VEC   $FFFE

}

.block global {

make_screen_black
		c64.EXTCOL = c64.BGCOL0 = 0
		c64.COLOR = 3
		return


; ---- print null terminated string from X/Y
print_string    ; (X, Y) -> (A?, Y?)
	asm {
		stx  c64.SCRATCH_ZP1
		sty  c64.SCRATCH_ZP2
		ldy  #0
-               lda  (c64.SCRATCH_ZP1),y
		beq  +
		jsr  c64.CHROUT
		iny
		bne  -
+               rts
	}

; ---- print pstring (length as first byte) from X/Y, returns str len in Y
print_pstring   ; (X, Y) -> (A?, X?, Y)
	asm {
		stx  c64.SCRATCH_ZP1
		sty  c64.SCRATCH_ZP2
		ldy  #0
		lda  (c64.SCRATCH_ZP1),y
		beq  +
		tax
-		iny
		lda  (c64.SCRATCH_ZP1),y
		jsr  c64.CHROUT
		dex
		bne  -
+               rts     ; output string length is in Y
	}


; ---- print pstring in memory immediately following the call instruction
print_pimmediate
	asm {
		tsx
		lda  $102,x
		tay             ; put high byte in y
		lda  $101,x
		tax             ; and low byte in x.
		inx
		bne  +
		iny
+               jsr  print_pstring   ; print string in XY, returns string length in y.
		tya
		tsx
		clc
		adc  $101,x     ; add content of 1st (length) byte to return addr.
		bcc  +          ; if that made the low byte roll over to 00,
		inc  $102,x     ; then increment the high byte too.
+               clc
		adc  #1         ; now add 1 for the length byte itself.
		sta  $101,x
		bne  +          ; if that made it (the low byte) roll over to 00,
		inc  $102,x     ; increment the high byte of the return addr too.
+               rts
	}


; ---- A to decimal string in Y/X/A  (100s in Y, 10s in X, 1s in A)
byte2decimal    ; (A) -> (Y, X, A)
	asm {
		ldy  #$2f
		ldx  #$3a
		sec
-               iny
		sbc  #100
		bcs  -
-               dex
		adc  #10
		bmi  -
		adc  #$2f
		rts
	}

; ---- A to hex string in XY (first hex char in X, second hex char in Y)
byte2hex        ; (A) -> (X, Y, A?)
	asm {
		pha
		and  #$0f
		tax
		ldy  hex_digits,x
		pla
		lsr  a
		lsr  a
		lsr  a
		lsr  a
		tax
		lda  hex_digits,x
		tax
		rts

hex_digits      .text "0123456789abcdef"     ; can probably be reused for other stuff as well
	}



; Convert an 16 bit binary value to BCD
;
; This function converts a 16 bit binary value in X/Y into a 24 bit BCD. It
; works by transferring one bit a time from the source and adding it
; into a BCD value that is being doubled on each iteration. As all the
; arithmetic is being done in BCD the result is a binary to decimal
; conversion.

		.var .array(3) word2bcd_bcdbuff

word2bcd        ; (XY) -> (A?, X?)
	asm {
		stx  c64.SCRATCH_ZP1
		sty  c64.SCRATCH_ZP2
		sed		; switch to decimal mode
		lda  #0		; ensure the result is clear
		sta  word2bcd_bcdbuff+0
		sta  word2bcd_bcdbuff+1
		sta  word2bcd_bcdbuff+2
		ldx  #16        ; the number of source bits

-		asl  c64.SCRATCH_ZP1     ; shift out one bit
		rol  c64.SCRATCH_ZP2
		lda  word2bcd_bcdbuff+0	; and add into result
		adc  word2bcd_bcdbuff+0
		sta  word2bcd_bcdbuff+0
		lda  word2bcd_bcdbuff+1	; propagating any carry
		adc  word2bcd_bcdbuff+1
		sta  word2bcd_bcdbuff+1
		lda  word2bcd_bcdbuff+2	; ... thru whole result
		adc  word2bcd_bcdbuff+2
		sta  word2bcd_bcdbuff+2
		dex		; and repeat for next bit
		bne  -
		cld		; back to binary
		rts
	}


; ---- convert 16 bit word in X/Y into decimal string into memory 'word2decimal_output'
		.var .array(5)      word2decimal_output
word2decimal    ; (X, Y) -> (A?, X?, Y?)
	asm {
		jsr  word2bcd
		lda  word2bcd_bcdbuff+2
		clc
		adc  #'0'
		sta  word2decimal_output
		ldy  #1
		lda  word2bcd_bcdbuff+1
		jsr  +
		lda  word2bcd_bcdbuff+0

+               pha
		lsr  a
		lsr  a
		lsr  a
		lsr  a
		clc
		adc  #'0'
		sta  word2decimal_output,y
		iny
		pla
		and  #$0f
		adc  #'0'
		sta  word2decimal_output,y
		iny
		rts
	}

; ---- print the byte in A in decimal form, with left padding 0s (3 positions total)
print_byte_decimal0      ; (A) -> (A?, X?, Y?)
	asm {
		jsr  byte2decimal
		pha
		tya
		jsr  c64.CHROUT
		txa
		jsr  c64.CHROUT
		pla
		jmp  c64.CHROUT
	}

; ---- print the byte in A in decimal form, without left padding 0s
print_byte_decimal      ; (A) -> (A?, X?, Y?)
	asm {
		jsr  byte2decimal
		pha
		tya
		cmp  #'0'
		beq  +
		jsr  c64.CHROUT
+		txa
		cmp  #'0'
		beq  +
		jsr  c64.CHROUT
+		pla
		jmp  c64.CHROUT
	}

; ---- print the byte in A in hex form
print_byte_hex          ; (A) -> (A?, X?, Y?)
	asm {
		jsr  byte2hex
		txa
		jsr  c64.CHROUT
		tya
		jmp  c64.CHROUT
	}

; ---- print the word in X/Y in decimal form, with left padding 0s (5 positions total)
print_word_decimal0      ; (XY) -> (A?, X?, Y?)
	asm {
		jsr  word2decimal
		lda  word2decimal_output
		jsr  c64.CHROUT
		lda  word2decimal_output+1
		jsr  c64.CHROUT
		lda  word2decimal_output+2
		jsr  c64.CHROUT
		lda  word2decimal_output+3
		jsr  c64.CHROUT
		lda  word2decimal_output+4
		jmp  c64.CHROUT
	}

; ---- print the word in X/Y in decimal form, without left padding 0s
print_word_decimal
	asm {
		jsr  word2decimal
		ldy  #0
		lda  word2decimal_output
		cmp  #'0'
		bne  _pr_decimal
		iny
		lda  word2decimal_output+1
		cmp  #'0'
		bne  _pr_decimal
		iny
		lda  word2decimal_output+2
		cmp  #'0'
		bne  _pr_decimal
		iny
		lda  word2decimal_output+3
		cmp  #'0'
		bne  _pr_decimal
		iny

_pr_decimal
                lda  word2decimal_output,y
		jsr  c64.CHROUT
		iny
		cpy  #5
		bcc  _pr_decimal
		rts
	}
}
