; IL65 definitions for the Commodore-64
; Including memory registers, I/O registers, Basic and Kernel subroutines, utility subroutines.
;
; Written by Irmen de Jong (irmen@razorvine.net)
; License: GNU GPL 3.0, see LICENSE

output raw

~ c64 {
		memory SCRATCH_ZP1	= $02		; scratch register #1 in ZP 
		memory SCRATCH_ZP2	= $03		; scratch register #2 in ZP

		memory COLOR		= $286		; cursor color

; ---- VIC-II registers ----

		memory SP0X		= $d000
		memory SP0Y		= $d001
		memory SP1X		= $d002
		memory SP1Y		= $d003
		memory SP2X		= $d004
		memory SP2Y		= $d005
		memory SP3X		= $d006
		memory SP3Y		= $d007
		memory SP4X		= $d008
		memory SP4Y		= $d009
		memory SP5X		= $d00a
		memory SP5Y		= $d00b
		memory SP6X		= $d00c
		memory SP6Y		= $d00d
		memory SP7X		= $d00e
		memory SP7Y		= $d00f

		memory MSIGX		= $d010
		memory SCROLY		= $d011
		memory RASTER		= $d012
		memory LPENX		= $d013
		memory LPENY		= $d014
		memory SPENA		= $d015
		memory SCROLX		= $d016
		memory YXPAND		= $d017
		memory VMCSB		= $d018
		memory VICIRQ		= $d019
		memory IREQMASK		= $d01a
		memory SPBGPR		= $d01b
		memory SPMC		= $d01c
		memory XXPAND		= $d01d
		memory SPSPCL		= $d01e
		memory SPBGCL		= $d01f

		memory EXTCOL		= $d020		; border color
		memory BGCOL0		= $d021		; screen color
		memory BGCOL1		= $d022
		memory BGCOL2		= $d023
		memory BGCOL4		= $d024
		memory SPMC0		= $d025
		memory SPMC1		= $d026
		memory SP0COL		= $d027
		memory SP1COL		= $d028
		memory SP2COL		= $d029
		memory SP3COL		= $d02a
		memory SP4COL		= $d02b
		memory SP5COL		= $d02c
		memory SP6COL		= $d02d
		memory SP7COL		= $d02e

; ---- end of VIC-II registers ----

; ---- C64 basic and kernal ROM float constants and functions ----

		; note: the fac1 and fac2 are working registers and take 6 bytes each,
		; floats in memory (and rom) are stored in 5-byte MFLPT packed format.

		; constants in five-byte "mflpt" format in the BASIC ROM
; @todo ?? use the symbol names from http://unusedino.de/ec64/technical/project64/mapping_c64.html
		memory  .float  mflpt_pi		= $aea8  ; 3.1415926...
		memory  .float  mflpt_minus32768	= $b1a5  ; -32768
		memory  .float  mflpt_1			= $b9bc  ; 1
		memory  .float  mflpt_half_sqr2		= $b9d6  ; SQR(2) / 2
		memory  .float  mflpt_sqr2		= $b9db  ; SQR(2)
		memory  .float  mflpt_minus_half  	= $b9e0  ; -.5
		memory  .float  mflpt_log_2		= $b9e5  ; LOG(2)
		memory  .float  mflpt_10		= $baf9  ; 10
		memory  .float  mflpt_1e9		= $bdbd  ; 1e9 (1 billion)
		memory  .float  mflpt_half		= $bf11  ; .5
		memory  .float  mflpt_one_over_log_2	= $bfbf  ; 1 / LOG(2)
		memory  .float  mflpt_half_pi		= $e2e0  ; PI / 2
		memory  .float  mflpt_double_pi		= $e2e5  ; 2 * PI
		memory  .float  mflpt_point25		= $e2ea  ; .25


; @todo verify clobbered registers?
; note: fac1/2 might get clobbered even if not mentioned in the function's name.
; note: for subtraction and division, the left operand is in fac2, the right operand in fac1.

; checked functions below:
subx	MOVFM		(AY) -> (A?, Y?)	= $bba2		; load mflpt value from memory in A/Y into fac1
subx	FREADMEM	() -> (A?, Y?)		= $bba6		; load mflpt value from memory in $22/$23 into fac1
subx    CONUPK		(AY) -> (A?, Y?)	= $ba8c		; load mflpt value from memory in A/Y into fac2
subx	FAREADMEM	() -> (A?, Y?)		= $ba90		; load mflpt value from memory in $22/$23 into fac2
subx	MOVFA		() -> (A?, X?)		= $bbfc		; copy fac2 to fac1
subx	MOVAF		() -> (A?, X?)		= $bc0c		; copy fac1 to fac2  (rounded)
subx	MOVEF		() -> (A?, X?)		= $bc0f		; copy fac1 to fac2
subx	FTOMEMXY	(XY) -> (A?, Y?)	= $bbd4		; store fac1 to memory X/Y as 5-byte mflpt
subx	FTOSWORDYA	() -> (Y, A, X?)	= $b1aa		; fac1-> signed word in Y/A (might throw ILLEGAL QUANTITY)
	; use c64util.FTOSWRDAY to get A/Y output (lo/hi switched to normal order)
subx	GETADR		() -> (Y, A, X?)	= $b7f7		; fac1 -> unsigned word in Y/A (might throw ILLEGAL QUANTITY)
	; (result also in $14/15) use c64util.GETADRAY to get A/Y output (lo/hi switched to normal order)
subx	QINT		() -> (A?, X?, Y?)	= $bc9b		; fac1 -> 4-byte signed integer in 98-101 ($62-$65), with the MSB FIRST.
subx	AYINT		() -> (A?, X?, Y?)	= $b1bf		; fac1-> signed word in 100-101 ($64-$65) MSB FIRST. (might throw ILLEGAL QUANTITY)
subx	GIVAYF		(Y, A) -> (A?, X?, Y?)	= $b391		; signed word in Y/A -> float in fac1
	; use c64util.GIVAYFAY to use A/Y input (lo/hi switched to normal order)
; there is also c64util.GIVUAYF - unsigned word in A/Y (lo/hi) to fac1  (AY) -> (A?, X?, Y?)
; there is also c64util.FREADS32  that reads from 98-101 ($62-$65) MSB FIRST
; there is also c64util.FREADUS32  that reads from 98-101 ($62-$65) MSB FIRST
; there is also c64util.FREADS24AXY  that reads signed int24 into fac1 from A/X/Y (lo/mid/hi bytes)
subx	FREADUY		(Y) -> (A?, X?, Y?)	= $b3a2		; 8 bit unsigned Y -> float in fac1
subx	FREADSA		(A) -> (A?, X?, Y?)	= $bc3c		; 8 bit signed A -> float in fac1
subx	FREADSTR	(A) -> (A?, X?, Y?)	= $b7b5		; str -> fac1, $22/23 must point to string, A=string length
subx	FPRINTLN	() -> (A?, X?, Y?)	= $aabc		; print string of fac1, on one line (= with newline)
subx	FOUT		() -> (AY, X?)		= $bddd		; fac1 -> string, address returned in AY ($0100)

subx	FADDH		() -> (A?, X?, Y?)	= $b849		; fac1 += 0.5, for rounding- call this before INT
subx	MUL10		() -> (A?, X?, Y?)	= $bae2		; fac1 *= 10
subx	DIV10		() -> (A?, X?, Y?)	= $bafe		; fac1 /= 10 , CAUTION: result is always positive!
subx	FCOMP		(AY) -> (A, X?, Y?)	= $bc5b		; A = compare fac1 to mflpt in A/Y, 0=equal 1=fac1 is greater, 255=fac1 is less than

subx	FADDT		() -> (A?, X?, Y?)	= $b86a		; fac1 += fac2
subx	FADD		(AY) -> (A?, X?, Y?)	= $b867		; fac1 += mflpt value from A/Y
subx	FSUBT		() -> (A?, X?, Y?)	= $b853		; fac1 = fac2-fac1   mind the order of the operands
subx	FSUB		(AY) -> (A?, X?, Y?)	= $b850		; fac1 = mflpt from A/Y - fac1
subx	FMULTT 		() -> (A?, X?, Y?)	= $ba2b		; fac1 *= fac2 
subx	FMULT		(AY) -> (A?, X?, Y?)	= $ba28		; fac1 *= mflpt value from A/Y
subx	FDIVT 		() -> (A?, X?, Y?)	= $bb12		; fac1 = fac2/fac1   mind the order of the operands
subx	FDIV  		(AY) -> (A?, X?, Y?)	= $bb0f		; fac1 = mflpt in A/Y / fac1
subx	FPWRT		() -> (A?, X?, Y?)	= $bf7b		; fac1 = fac2 ** fac1
subx	FPWR		(AY) -> (A?, X?, Y?)	= $bf78		; fac1 = fac2 ** mflpt from A/Y

subx    NOTOP		() -> (A?, X?, Y?)	= $aed4		; fac1 = NOT(fac1)
subx	INT		() -> (A?, X?, Y?)	= $bccc		; INT() truncates, use FADDH first to round instead of trunc
subx	LOG		() -> (A?, X?, Y?)	= $b9ea		; fac1 = LN(fac1)  (natural log)
subx	SGN		() -> (A?, X?, Y?)	= $bc39		; fac1 = SGN(fac1), result of SIGN (-1, 0 or 1)
subx	SIGN		() -> (A)		= $bc2b		; SIGN(fac1) to A, $ff, $0, $1 for negative, zero, positive
subx	ABS		() -> ()		= $bc58		; fac1 = ABS(fac1)
subx	SQR		() -> (A?, X?, Y?)	= $bf71		; fac1 = SQRT(fac1)
subx	EXP		() -> (A?, X?, Y?)	= $bfed		; fac1 = EXP(fac1)  (e ** fac1)
subx	NEGOP		() -> (A?)		= $bfb4		; switch the sign of fac1
subx	RND		() -> (A?, X?, Y?)	= $e097		; fac1 = RND()
subx	COS		() -> (A?, X?, Y?)	= $e264		; fac1 = COS(fac1)
subx	SIN		() -> (A?, X?, Y?)	= $e26b		; fac1 = SIN(fac1)
subx	TAN		() -> (A?, X?, Y?)	= $e2b4		; fac1 = TAN(fac1)
subx	ATN		() -> (A?, X?, Y?)	= $e30e		; fac1 = ATN(fac1)


; ---- C64 basic routines ----

subx    CLEARSCR    () -> (A?, X?, Y?)                          = $E544   ; clear the screen
subx    HOMECRSR    () -> (A?, X?, Y?)                          = $E566   ; cursor to top left of screen


; ---- end of C64 basic routines ----



; ---- C64 kernal routines ----

subx    CINT     () -> (A?, X?, Y?)                             = $FF81    ; (alias: SCINIT) initialize screen editor and video chip
subx    IOINIT   () -> (A?, X?)                                 = $FF84    ; initialize I/O devices
subx    RAMTAS   () -> (A?, X?, Y?)                             = $FF87    ; initialize RAM, tape buffer, screen
subx    RESTOR   () -> ()                                       = $FF8A    ; restore default I/O vectors
subx    VECTOR   (direction: SC, userptr: XY) -> (A?, Y?)       = $FF8D    ; read/set I/O vector table
subx    SETMSG   (value: A) -> ()                               = $FF90    ; set Kernal message control flag
subx    SECOND   (address: A) -> (A?)                           = $FF93    ; (alias: LSTNSA) send secondary address after LISTEN
subx    TKSA     (address: A) -> (A?)                           = $FF96    ; (alias: TALKSA) send secondary address after TALK
subx    MEMTOP   (direction: SC, address: XY) -> (XY)           = $FF99    ; read/set top of memory pointer
subx    MEMBOT   (direction: SC, address: XY) -> (XY)           = $FF9C    ; read/set bottom of memory pointer
subx    SCNKEY   () -> (A?, X?, Y?)                             = $FF9F    ; scan the keyboard
subx    SETTMO   (timeout: A) -> ()                             = $FFA2    ; set time-out flag for IEEE bus
subx    ACPTR    () -> (A)                                      = $FFA5    ; (alias: IECIN) input byte from serial bus
subx    CIOUT    (byte: A) -> ()                                = $FFA8    ; (alias: IECOUT) output byte to serial bus
subx    UNTLK    () -> (A?)                                     = $FFAB    ; command serial bus device to UNTALK
subx    UNLSN    () -> (A?)                                     = $FFAE    ; command serial bus device to UNLISTEN
subx    LISTEN   (device: A) -> (A?)                            = $FFB1    ; command serial bus device to LISTEN
subx    TALK     (device: A) -> (A?)                            = $FFB4    ; command serial bus device to TALK
subx    READST   () -> (A)                                      = $FFB7    ; read I/O status word
subx    SETLFS   (logical: A, device: X, address: Y) -> ()      = $FFBA    ; set logical file parameters
subx    SETNAM   (namelen: A, filename: XY) -> ()               = $FFBD    ; set filename parameters
subx    OPEN     () -> (A?, X?, Y?)                             = $FFC0    ; (via 794 ($31A)) open a logical file
subx    CLOSE    (logical: A) -> (A?, X?, Y?)                   = $FFC3    ; (via 796 ($31C)) close a logical file
subx    CHKIN    (logical: X) -> (A?, X?)                       = $FFC6    ; (via 798 ($31E)) define an input channel
subx    CHKOUT   (logical: X) -> (A?, X?)                       = $FFC9    ; (via 800 ($320)) define an output channel
subx    CLRCHN   () -> (A?, X?)                                 = $FFCC    ; (via 802 ($322)) restore default devices
subx    CHRIN    () -> (A, Y?)                                  = $FFCF    ; (via 804 ($324)) input a character
subx    CHROUT   (char: A) -> ()                                = $FFD2    ; (via 806 ($326)) output a character
subx    LOAD     (verify: A, address: XY) -> (SC, A, X, Y)      = $FFD5    ; (via 816 ($330)) load from device
subx    SAVE     (zp_startaddr: A, endaddr: XY) -> (SC, A)      = $FFD8    ; (via 818 ($332)) save to a device
subx    SETTIM   (low: A, middle: X, high: Y) -> ()             = $FFDB    ; set the software clock
subx    RDTIM    () -> (A, X, Y)                                = $FFDE    ; read the software clock
subx    STOP     () -> (SZ, SC, A?, X?)                         = $FFE1    ; (via 808 ($328)) check the STOP key
subx    GETIN    () -> (A, X?, Y?)                              = $FFE4    ; (via 810 ($32A)) get a character
subx    CLALL    () -> (A?, X?)                                 = $FFE7    ; (via 812 ($32C)) close all files
subx    UDTIM    () -> (A?, X?)                                 = $FFEA    ; update the software clock
subx    SCREEN   () -> (X, Y)                                   = $FFED    ; read number of screen rows and columns
subx    PLOT     (direction: SC, column: X, row: Y) -> (X, Y)   = $FFF0    ; read/set position of cursor on screen
subx    IOBASE   () -> (X, Y)                                   = $FFF3    ; read base address of I/O devices

; ---- end of C64 kernal routines ----

		memory .word NMI_VEC   	= $FFFA
		memory .word RESET_VEC 	= $FFFC
		memory .word IRQ_VEC   	= $FFFE

}

~ c64util {

; ---- fac1 = signed int32 from $62-$65 big endian (MSB FIRST)
FREADS32	; () -> (A?, X?, Y?)
	asm {
		lda  $62
		eor  #$ff
		asl  a
		lda  #0
		ldx  #$a0
		jmp  $bc4f
	}

; ---- fac1 = uint32 from $62-$65 big endian (MSB FIRST)
FREADUS32	; () -> (A?, X?, Y?)
	asm {
		sec
		lda  #0
		ldx  #$a0
		jmp  $bc4f
	}

; ---- fac1 = signed int24 (A/X/Y contain lo/mid/hi bytes)
;      note: there is no FREADU24AXY (unsigned), use FREADUS32 instead. 
FREADS24AXY	; (A, X, Y) -> (A?, X?, Y?)
	asm {
		sty  $62
		stx  $63
		sta  $64
		lda  $62
		eor  #$FF
		asl  a
		lda  #0
		sta  $65
		ldx  #$98
		jmp  $bc4f
	}

	
; ---- unsigned 16 bit word in A/Y (lo/hi) to fac1
GIVUAYF    ; (AY) -> (A?, X?, Y?)
	asm {
		sty  $62
		sta  $63
		ldx  #$90
		sec
		jmp  $bc49
	}

; ---- signed 16 bit word in A/Y (lo/hi) to float in fac1
GIVAYFAY	; (AY) -> (A?, X?, Y?)
	asm {
		sta  c64.SCRATCH_ZP1
		tya
		ldy  c64.SCRATCH_ZP1
		jmp  c64.GIVAYF			; this uses the inverse order, Y/A
	}
	
; ---- fac1 to signed word in A/Y
FTOSWRDAY	; () -> (A, Y, X?)
	asm {
		jsr  c64.FTOSWORDYA		; note the inverse Y/A order
		sta  c64.SCRATCH_ZP1
		tya
		ldy  c64.SCRATCH_ZP1
		rts
	}

; ---- fac1 to unsigned word in A/Y
GETADRAY	; () -> (A, Y, X?)
	asm {
		jsr  c64.GETADR			; this uses the inverse order, Y/A
		sta  c64.SCRATCH_ZP1
		tya
		ldy  c64.SCRATCH_ZP1
		rts
	}
	

; ---- print null terminated string from X/Y
print_string    ; (X, Y) -> (A?, Y?)
	asm {
		stx  c64.SCRATCH_ZP1
		sty  c64.SCRATCH_ZP2
		ldy  #0
-               lda  (c64.SCRATCH_ZP1),y
		beq  +
		jsr  c64.CHROUT
		iny
		bne  -
+		rts
	}

; ---- print pstring (length as first byte) from X/Y, returns str len in Y
print_pstring   ; (X, Y) -> (A?, X?, Y)
	asm {
		stx  c64.SCRATCH_ZP1
		sty  c64.SCRATCH_ZP2
		ldy  #0
		lda  (c64.SCRATCH_ZP1),y
		beq  +
		tax
-		iny
		lda  (c64.SCRATCH_ZP1),y
		jsr  c64.CHROUT
		dex
		bne  -
+		rts     ; output string length is in Y
	}


; ---- print pstring in memory immediately following the call instruction
print_pimmediate
	asm {
		tsx
		lda  $102,x
		tay             ; put high byte in y
		lda  $101,x
		tax             ; and low byte in x.
		inx
		bne  +
		iny
+		jsr  print_pstring   ; print string in XY, returns string length in y.
		tya
		tsx
		clc
		adc  $101,x     ; add content of 1st (length) byte to return addr.
		bcc  +          ; if that made the low byte roll over to 00,
		inc  $102,x     ; then increment the high byte too.
+		clc
		adc  #1         ; now add 1 for the length byte itself.
		sta  $101,x
		bne  +          ; if that made it (the low byte) roll over to 00,
		inc  $102,x     ; increment the high byte of the return addr too.
+		rts
	}


; ---- A to decimal string in Y/X/A  (100s in Y, 10s in X, 1s in A)
byte2decimal    ; (A) -> (Y, X, A)
	asm {
		ldy  #$2f
		ldx  #$3a
		sec
-               iny
		sbc  #100
		bcs  -
-               dex
		adc  #10
		bmi  -
		adc  #$2f
		rts
	}

; ---- A to hex string in XY (first hex char in X, second hex char in Y)
byte2hex        ; (A) -> (X, Y, A?)
	asm {
		pha
		and  #$0f
		tax
		ldy  hex_digits,x
		pla
		lsr  a
		lsr  a
		lsr  a
		lsr  a
		tax
		lda  hex_digits,x
		tax
		rts

hex_digits      .text "0123456789abcdef"     ; can probably be reused for other stuff as well
	}



; Convert an 16 bit binary value to BCD
;
; This function converts a 16 bit binary value in X/Y into a 24 bit BCD. It
; works by transferring one bit a time from the source and adding it
; into a BCD value that is being doubled on each iteration. As all the
; arithmetic is being done in BCD the result is a binary to decimal
; conversion.

		var .array(3)	word2bcd_bcdbuff

word2bcd        ; (XY) -> (A?, X?)
	asm {
		stx  c64.SCRATCH_ZP1
		sty  c64.SCRATCH_ZP2
		sed		; switch to decimal mode
		lda  #0		; ensure the result is clear
		sta  word2bcd_bcdbuff+0
		sta  word2bcd_bcdbuff+1
		sta  word2bcd_bcdbuff+2
		ldx  #16        ; the number of source bits

-		asl  c64.SCRATCH_ZP1     ; shift out one bit
		rol  c64.SCRATCH_ZP2
		lda  word2bcd_bcdbuff+0	; and add into result
		adc  word2bcd_bcdbuff+0
		sta  word2bcd_bcdbuff+0
		lda  word2bcd_bcdbuff+1	; propagating any carry
		adc  word2bcd_bcdbuff+1
		sta  word2bcd_bcdbuff+1
		lda  word2bcd_bcdbuff+2	; ... thru whole result
		adc  word2bcd_bcdbuff+2
		sta  word2bcd_bcdbuff+2
		dex		; and repeat for next bit
		bne  -
		cld		; back to binary
		rts
	}


; ---- convert 16 bit word in X/Y into decimal string into memory 'word2decimal_output'
		var .array(5)      word2decimal_output

word2decimal    ; (X, Y) -> (A?, X?, Y?)
	asm {
		jsr  word2bcd
		lda  word2bcd_bcdbuff+2
		clc
		adc  #'0'
		sta  word2decimal_output
		ldy  #1
		lda  word2bcd_bcdbuff+1
		jsr  +
		lda  word2bcd_bcdbuff+0

+		pha
		lsr  a
		lsr  a
		lsr  a
		lsr  a
		clc
		adc  #'0'
		sta  word2decimal_output,y
		iny
		pla
		and  #$0f
		adc  #'0'
		sta  word2decimal_output,y
		iny
		rts
	}

; ---- print the byte in A in decimal form, with left padding 0s (3 positions total)
print_byte_decimal0      ; (A) -> (A?, X?, Y?)
	asm {
		jsr  byte2decimal
		pha
		tya
		jsr  c64.CHROUT
		txa
		jsr  c64.CHROUT
		pla
		jmp  c64.CHROUT
	}

; ---- print the byte in A in decimal form, without left padding 0s
print_byte_decimal      ; (A) -> (A?, X?, Y?)
	asm {
		jsr  byte2decimal
		pha
		tya
		cmp  #'0'
		beq  +
		jsr  c64.CHROUT
+		txa
		cmp  #'0'
		beq  +
		jsr  c64.CHROUT
+		pla
		jmp  c64.CHROUT
	}

; ---- print the byte in A in hex form
print_byte_hex          ; (A) -> (A?, X?, Y?)
	asm {
		jsr  byte2hex
		txa
		jsr  c64.CHROUT
		tya
		jmp  c64.CHROUT
	}

; ---- print the word in X/Y in decimal form, with left padding 0s (5 positions total)
print_word_decimal0      ; (XY) -> (A?, X?, Y?)
	asm {
		jsr  word2decimal
		lda  word2decimal_output
		jsr  c64.CHROUT
		lda  word2decimal_output+1
		jsr  c64.CHROUT
		lda  word2decimal_output+2
		jsr  c64.CHROUT
		lda  word2decimal_output+3
		jsr  c64.CHROUT
		lda  word2decimal_output+4
		jmp  c64.CHROUT
	}

; ---- print the word in X/Y in decimal form, without left padding 0s
print_word_decimal	; (XY) -> (A?, X? Y?)
	asm {
		jsr  word2decimal
		ldy  #0
		lda  word2decimal_output
		cmp  #'0'
		bne  _pr_decimal
		iny
		lda  word2decimal_output+1
		cmp  #'0'
		bne  _pr_decimal
		iny
		lda  word2decimal_output+2
		cmp  #'0'
		bne  _pr_decimal
		iny
		lda  word2decimal_output+3
		cmp  #'0'
		bne  _pr_decimal
		iny

_pr_decimal
		lda  word2decimal_output,y
		jsr  c64.CHROUT
		iny
		cpy  #5
		bcc  _pr_decimal
		rts
	}
}
