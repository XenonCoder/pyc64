; IL65 global definitions for the Commodore-64
; Including memory registers, I/O registers, Basic and Kernel subroutines.
;
; Written by Irmen de Jong (irmen@razorvine.net)
; License: GNU GPL 3.0, see LICENSE

output raw

~ c64 {
		memory SCRATCH_ZP1      = $02
		memory SCRATCH_ZP2      = $03

		memory COLOR            = $286        ; cursor color

; ---- VIC-II registers ----

		memory SP0X        = $d000
		memory SP0Y        = $d001
		memory SP1X        = $d002
		memory SP1Y        = $d003
		memory SP2X        = $d004
		memory SP2Y        = $d005
		memory SP3X        = $d006
		memory SP3Y        = $d007
		memory SP4X        = $d008
		memory SP4Y        = $d009
		memory SP5X        = $d00a
		memory SP5Y        = $d00b
		memory SP6X        = $d00c
		memory SP6Y        = $d00d
		memory SP7X        = $d00e
		memory SP7Y        = $d00f

		memory MSIGX       = $d010
		memory SCROLY      = $d011
		memory RASTER      = $d012
		memory LPENX       = $d013
		memory LPENY       = $d014
		memory SPENA       = $d015
		memory SCROLX      = $d016
		memory YXPAND      = $d017
		memory VMCSB       = $d018
		memory VICIRQ      = $d019
		memory IREQMASK    = $d01a
		memory SPBGPR      = $d01b
		memory SPMC        = $d01c
		memory XXPAND      = $d01d
		memory SPSPCL      = $d01e
		memory SPBGCL      = $d01f

		memory EXTCOL      = $d020       ; border color
		memory BGCOL0      = $d021       ; screen color
		memory BGCOL1      = $d022
		memory BGCOL2      = $d023
		memory BGCOL4      = $d024
		memory SPMC0       = $d025
		memory SPMC1       = $d026
		memory SP0COL      = $d027
		memory SP1COL      = $d028
		memory SP2COL      = $d029
		memory SP3COL      = $d02a
		memory SP4COL      = $d02b
		memory SP5COL      = $d02c
		memory SP6COL      = $d02d
		memory SP7COL      = $d02e

; ---- end of VIC-II registers ----

; ---- C64 basic ROM float constants and functions ----

		; constants in five-byte "mflpt" format in the BASIC ROM
		memory .float mflpt_pi			= $aea8	; 3.1415926...   (82 49 0F DA A1)
		memory .float mflpt_minus32768		= $b1a5	; -32768         (90 80 00 00 00)
		memory .float mflpt_1			= $b9bc	; 1              (81 00 00 00 00)
		memory .float mflpt_half_sqr2		= $b9d6	; SQR(2) / 2     (80 35 04 F3 34)
		memory .float mflpt_sqr2		= $b9db	; SQR(2)         (81 35 04 F3 34)
		memory .float mflpt_minus_half  	= $b9e0	; -.5            (80 80 00 00 00)
		memory .float mflpt_log_2		= $b9e5	; LOG(2)         (80 31 72 17 F8)
		memory .float mflpt_10			= $baf9	; 10             (84 20 00 00 00)
		memory .float mflpt_1e9		        = $bdbd	; 1 000 000 000  (9E 6E 6B 28 00)
		memory .float mflpt_half        	= $bf11	; .5             (80 00 00 00 00)
		memory .float mflpt_one_over_log_2	= $bfbf	; 1 / LOG(2)     (81 38 AA 3B 29)
		memory .float mflpt_half_pi		= $e2e0	; PI / 2         (81 49 0F DA A2)
		memory .float mflpt_double_pi		= $e2e5	; 2 * PI         (83 49 0F DA A2)
		memory .float mflpt_point25		= $e2ea	; .25            (7F 00 00 00 00)


; @todo better params, see also https://www.c64-wiki.com/wiki/Floating_point_arithmetic#Routines_for_converting_between_floating_point_and_other_formats
; @todo A/Y order (which is lo, which is high byte?)
; functions - a few points to note:
; fac1/2 might get clobbered even if not mentioned in the function's name,
;	because stuff like fac1_times_memAY will load the value from memory
;	into fac2 first.
; for subtraction and division, the left operand is in fac2, the right operand in fac1.
subx	fac1_print		() -> (A?, X?, Y?)	        = $aabc	; print string representation of contents of fac1, on one line
subx    fac1_not                () -> (A?, X?, Y?)              = $aed4 ; Not()
subx	fac1_to_signedAY	() -> (A?, X?, Y?)	        = $b1aa	; fac1-> signed 16 bit in A/Y,  might throw ILLEGAL QUANTITY
subx	fac1_to_signed16	() -> (A?, X?, Y?)	        = $b1bf	; fac1-> signed 16 bit in fac1, might throw ILLEGAL QUANTITY   @todo 16 bit???
subx	fac1_read_signedAY	() -> (A?, X?, Y?)	        = $b391	; convert 16 bit signed int in A/Y (lo/hi) to float
subx	fac1_read_unsignedY	(Y) -> (A?, X?, Y?)	        = $b3a2	; convert 8 bit unsigned int in Y to float
; fac1_read_unsignedAY = unsigned 16 bit word in A/Y (lo/hi) to fac, is defined as a routine in the global block
subx	fac1_read_signedA	(A) -> (A?, X?, Y?)	        = $bc3c	; convert 8 bit signed int in A to float
subx	fac1_read_string	() -> (A?, X?, Y?)	        = $b7b5	; $22/23 must point to string, A must be string length
subx	fac1_to_string		() -> (A?, X?, Y?)	        = $bddd	; string is stored at $0100 (address returned in AY)
subx	fac1_to_unsignedAY	() -> (A?, X?, Y?)	        = $b7f7	; fac1 -> unsigned 16 bit in A/Y might throw ILLEGAL QUANTITY (result is also in $14/15)
subx	fac1_add_point5		() -> (A?, X?, Y?)	        = $b849	; for rounding, call this before fac1_int
subx	fac1_memAY_minus_fac1	() -> (A?, X?, Y?)	        = $b850	; subtract fac1 from mflpt value
subx	fac1_fac2_minus_fac1	() -> (A?, X?, Y?)	        = $b853 ; fac1 = fac2-fac1
subx	fac1_add_memAY		() -> (A?, X?, Y?)	        = $b867	; add mflpt value
subx	fac1_add_fac2		() -> (A?, X?, Y?)	        = $b86a ; fac1 = fac1+fac2
subx	fac1_log		() -> (A?, X?, Y?)	        = $b9ea	; LOG()
subx	fac1_times_memAY	() -> (A?, X?, Y?)	        = $ba28	; multiply by mflpt value
subx	fac1_times_fac2 	() -> (A?, X?, Y?)	        = $ba2b	; fac1*fac2 -> fac1
subx	fac1_divide_fac2 	() -> (A?, X?, Y?)	        = $bb12	; fac1/fac2 -> fac1
subx	fac1_times_10		() -> (A?, X?, Y?)	        = $bae2 ; fac1 *= 10
subx	fac1_divide_by_10	() -> (A?, X?, Y?)	        = $bafe	; fac1 /= 10 , CAUTION: result is always positive!
subx	fac1_divide_memAY_by_fac1  () -> (A?, X?, Y?)	        = $bb0f	; divide mflpt in A/Y value by fac1 value
subx	fac1_read_memAY		(AY) -> (A?, X?, Y?)	        = $bba2	; load mflpt value from memory in A/Y into fac1
subx	fac1_read_mem0x22	() -> (A?, X?, Y?)	        = $bba6	; load mflpt value from memory in $22/$23 into fac1
subx    fac2_read_memAY         (AY) -> (A?, X?, Y?)            = $ba8c ; load mflpt value from memory in A/Y into fac2
subx	fac2_read_mem0x22	() -> (A?, X?, Y?)	        = $ba90	; load mflpt value from memory in $22/$23 into fac2
subx	fac1_to_memXY		(XY) -> (A?, X?, Y?)	        = $bbd4	; store fac1 to memory X/Y as mflpt
subx	fac1_read_fac2		() -> (A?, X?, Y?)	        = $bbfc	; copy fac2 to fac1   @todo also rounds?
subx	fac2_read_fac1		() -> (A?, X?, Y?)	        = $bc0c	; copy fac1 to fac2   @todo also rounds?
subx    fac1_round              () -> (A?, X?, Y?)              = $bc1b ; round         @todo what does this even do?
subx	fac1_sign_to_A		() -> (A)	                = $bc2b	; SIGN: A= $ff, $0, $1 for negative, zero, positive
subx	fac1_sgn		() -> (A?, X?, Y?)	        = $bc39	; SGN(), result of SIGN in fac1
subx	fac1_abs		() -> (A?, X?, Y?)	        = $bc58	; ABS()
subx	fac1_compare_to_memAY	() -> (A, X?, Y?)	        = $bc5b	; compare to mflpt value in memory
subx	fac1_to_signed32	() -> (A?, X?, Y?)	        = $bc9b ; @todo fac is 32 bits int?  Y/A is lo/hi 16 bit unsigned??
subx	fac1_int		() -> (A?, X?, Y?)	        = $bccc	; INT(), use fac1_add_point5 first to round instead of trunc
subx	fac1_print_unsignedAX	() -> (A?, X?, Y?)	        = $bdcd ; this uses fac, so print_word_decimal() is a lot faster!
subx	fac1_sqr		() -> (A?, X?, Y?)	        = $bf71 ; SQR()
subx	fac1_fac2_to_the_power_of_memAY  (AY) -> (A?, X?, Y?)	= $bf78 ; fac1 = fac2 ** mflpt from mem pointed to by A/Y
subx	fac1_negate		() -> (A?, X?, Y?)	        = $bfb4 ; switch sign on the number in fac1
subx	fac1_exp		() -> (A?, X?, Y?)	        = $bfed	; EXP()
subx	fac1_pow_fac2		() -> (A?, X?, Y?)	        = $bf7b	; fac1 ** fac2 -> fac1  @todo or fac2 ** fac1?
; KERNEL ROM FUNCTIONS:
subx	fac1_rnd		() -> (A?, X?, Y?)	        = $e097	; RND()
subx	fac1_cos		() -> (A?, X?, Y?)	        = $e264	; COS()
subx	fac1_sin		() -> (A?, X?, Y?)	        = $e26b	; SIN()
subx	fac1_tan		() -> (A?, X?, Y?)	        = $e2b4	; TAN()
subx	fac1_atn		() -> (A?, X?, Y?)	        = $e30e	; ATN()


; ---- C64 basic routines ----

subx    CLEARSCR    () -> (A?, X?, Y?)                          = $E544   ; clear the screen
subx    HOMECRSR    () -> (A?, X?, Y?)                          = $E566   ; cursor to top left of screen




; ---- end of C64 basic routines ----

; ---- C64 kernal routines ----

subx    CINT     () -> (A?, X?, Y?)                             = $FF81    ; (alias: SCINIT) initialize screen editor and video chip
subx    IOINIT   () -> (A?, X?)                                 = $FF84    ; initialize I/O devices
subx    RAMTAS   () -> (A?, X?, Y?)                             = $FF87    ; initialize RAM, tape buffer, screen
subx    RESTOR   () -> ()                                       = $FF8A    ; restore default I/O vectors
subx    VECTOR   (direction: SC, userptr: XY) -> (A?, Y?)       = $FF8D    ; read/set I/O vector table
subx    SETMSG   (value: A) -> ()                               = $FF90    ; set Kernal message control flag
subx    SECOND   (address: A) -> (A?)                           = $FF93    ; (alias: LSTNSA) send secondary address after LISTEN
subx    TKSA     (address: A) -> (A?)                           = $FF96    ; (alias: TALKSA) send secondary address after TALK
subx    MEMTOP   (direction: SC, address: XY) -> (XY)           = $FF99    ; read/set top of memory pointer
subx    MEMBOT   (direction: SC, address: XY) -> (XY)           = $FF9C    ; read/set bottom of memory pointer
subx    SCNKEY   () -> (A?, X?, Y?)                             = $FF9F    ; scan the keyboard
subx    SETTMO   (timeout: A) -> ()                             = $FFA2    ; set time-out flag for IEEE bus
subx    ACPTR    () -> (A)                                      = $FFA5    ; (alias: IECIN) input byte from serial bus
subx    CIOUT    (byte: A) -> ()                                = $FFA8    ; (alias: IECOUT) output byte to serial bus
subx    UNTLK    () -> (A?)                                     = $FFAB    ; command serial bus device to UNTALK
subx    UNLSN    () -> (A?)                                     = $FFAE    ; command serial bus device to UNLISTEN
subx    LISTEN   (device: A) -> (A?)                            = $FFB1    ; command serial bus device to LISTEN
subx    TALK     (device: A) -> (A?)                            = $FFB4    ; command serial bus device to TALK
subx    READST   () -> (A)                                      = $FFB7    ; read I/O status word
subx    SETLFS   (logical: A, device: X, address: Y) -> ()      = $FFBA    ; set logical file parameters
subx    SETNAM   (namelen: A, filename: XY) -> ()               = $FFBD    ; set filename parameters
subx    OPEN     () -> (A?, X?, Y?)                             = $FFC0    ; (via 794 ($31A)) open a logical file
subx    CLOSE    (logical: A) -> (A?, X?, Y?)                   = $FFC3    ; (via 796 ($31C)) close a logical file
subx    CHKIN    (logical: X) -> (A?, X?)                       = $FFC6    ; (via 798 ($31E)) define an input channel
subx    CHKOUT   (logical: X) -> (A?, X?)                       = $FFC9    ; (via 800 ($320)) define an output channel
subx    CLRCHN   () -> (A?, X?)                                 = $FFCC    ; (via 802 ($322)) restore default devices
subx    CHRIN    () -> (A, Y?)                                  = $FFCF    ; (via 804 ($324)) input a character
subx    CHROUT   (char: A) -> ()                                = $FFD2    ; (via 806 ($326)) output a character
subx    LOAD     (verify: A, address: XY) -> (SC, A, X, Y)      = $FFD5    ; (via 816 ($330)) load from device
subx    SAVE     (zp_startaddr: A, endaddr: XY) -> (SC, A)      = $FFD8    ; (via 818 ($332)) save to a device
subx    SETTIM   (low: A, middle: X, high: Y) -> ()             = $FFDB    ; set the software clock
subx    RDTIM    () -> (A, X, Y)                                = $FFDE    ; read the software clock
subx    STOP     () -> (SZ, SC, A?, X?)                         = $FFE1    ; (via 808 ($328)) check the STOP key
subx    GETIN    () -> (A, X?, Y?)                              = $FFE4    ; (via 810 ($32A)) get a character
subx    CLALL    () -> (A?, X?)                                 = $FFE7    ; (via 812 ($32C)) close all files
subx    UDTIM    () -> (A?, X?)                                 = $FFEA    ; update the software clock
subx    SCREEN   () -> (X, Y)                                   = $FFED    ; read number of screen rows and columns
subx    PLOT     (direction: SC, column: X, row: Y) -> (X, Y)   = $FFF0    ; read/set position of cursor on screen
subx    IOBASE   () -> (X, Y)                                   = $FFF3    ; read base address of I/O devices

; ---- end of C64 kernal routines ----

		memory .word NMI_VEC   	= $FFFA
		memory .word RESET_VEC 	= $FFFC
		memory .word IRQ_VEC   	= $FFFE

}

~ global {

; ---- unsigned 16 bit word in A/Y (lo/hi) to fac
fac1_read_unsignedAY    ; (AY) -> (A?, X?, Y?)
        asm {
                sta  $62
                sty  $63
                sec
                ldx  #$90
                jmp  $bc49
        }

; ---- print null terminated string from X/Y
print_string    ; (X, Y) -> (A?, Y?)
	asm {
		stx  c64.SCRATCH_ZP1
		sty  c64.SCRATCH_ZP2
		ldy  #0
-               lda  (c64.SCRATCH_ZP1),y
		beq  +
		jsr  c64.CHROUT
		iny
		bne  -
+               rts
	}

; ---- print pstring (length as first byte) from X/Y, returns str len in Y
print_pstring   ; (X, Y) -> (A?, X?, Y)
	asm {
		stx  c64.SCRATCH_ZP1
		sty  c64.SCRATCH_ZP2
		ldy  #0
		lda  (c64.SCRATCH_ZP1),y
		beq  +
		tax
-		iny
		lda  (c64.SCRATCH_ZP1),y
		jsr  c64.CHROUT
		dex
		bne  -
+               rts     ; output string length is in Y
	}


; ---- print pstring in memory immediately following the call instruction
print_pimmediate
	asm {
		tsx
		lda  $102,x
		tay             ; put high byte in y
		lda  $101,x
		tax             ; and low byte in x.
		inx
		bne  +
		iny
+               jsr  print_pstring   ; print string in XY, returns string length in y.
		tya
		tsx
		clc
		adc  $101,x     ; add content of 1st (length) byte to return addr.
		bcc  +          ; if that made the low byte roll over to 00,
		inc  $102,x     ; then increment the high byte too.
+               clc
		adc  #1         ; now add 1 for the length byte itself.
		sta  $101,x
		bne  +          ; if that made it (the low byte) roll over to 00,
		inc  $102,x     ; increment the high byte of the return addr too.
+               rts
	}


; ---- A to decimal string in Y/X/A  (100s in Y, 10s in X, 1s in A)
byte2decimal    ; (A) -> (Y, X, A)
	asm {
		ldy  #$2f
		ldx  #$3a
		sec
-               iny
		sbc  #100
		bcs  -
-               dex
		adc  #10
		bmi  -
		adc  #$2f
		rts
	}

; ---- A to hex string in XY (first hex char in X, second hex char in Y)
byte2hex        ; (A) -> (X, Y, A?)
	asm {
		pha
		and  #$0f
		tax
		ldy  hex_digits,x
		pla
		lsr  a
		lsr  a
		lsr  a
		lsr  a
		tax
		lda  hex_digits,x
		tax
		rts

hex_digits      .text "0123456789abcdef"     ; can probably be reused for other stuff as well
	}



; Convert an 16 bit binary value to BCD
;
; This function converts a 16 bit binary value in X/Y into a 24 bit BCD. It
; works by transferring one bit a time from the source and adding it
; into a BCD value that is being doubled on each iteration. As all the
; arithmetic is being done in BCD the result is a binary to decimal
; conversion.

		var .array(3)	word2bcd_bcdbuff

word2bcd        ; (XY) -> (A?, X?)
	asm {
		stx  c64.SCRATCH_ZP1
		sty  c64.SCRATCH_ZP2
		sed		; switch to decimal mode
		lda  #0		; ensure the result is clear
		sta  word2bcd_bcdbuff+0
		sta  word2bcd_bcdbuff+1
		sta  word2bcd_bcdbuff+2
		ldx  #16        ; the number of source bits

-		asl  c64.SCRATCH_ZP1     ; shift out one bit
		rol  c64.SCRATCH_ZP2
		lda  word2bcd_bcdbuff+0	; and add into result
		adc  word2bcd_bcdbuff+0
		sta  word2bcd_bcdbuff+0
		lda  word2bcd_bcdbuff+1	; propagating any carry
		adc  word2bcd_bcdbuff+1
		sta  word2bcd_bcdbuff+1
		lda  word2bcd_bcdbuff+2	; ... thru whole result
		adc  word2bcd_bcdbuff+2
		sta  word2bcd_bcdbuff+2
		dex		; and repeat for next bit
		bne  -
		cld		; back to binary
		rts
	}


; ---- convert 16 bit word in X/Y into decimal string into memory 'word2decimal_output'
		var .array(5)      word2decimal_output

word2decimal    ; (X, Y) -> (A?, X?, Y?)
	asm {
		jsr  word2bcd
		lda  word2bcd_bcdbuff+2
		clc
		adc  #'0'
		sta  word2decimal_output
		ldy  #1
		lda  word2bcd_bcdbuff+1
		jsr  +
		lda  word2bcd_bcdbuff+0

+               pha
		lsr  a
		lsr  a
		lsr  a
		lsr  a
		clc
		adc  #'0'
		sta  word2decimal_output,y
		iny
		pla
		and  #$0f
		adc  #'0'
		sta  word2decimal_output,y
		iny
		rts
	}

; ---- print the byte in A in decimal form, with left padding 0s (3 positions total)
print_byte_decimal0      ; (A) -> (A?, X?, Y?)
	asm {
		jsr  byte2decimal
		pha
		tya
		jsr  c64.CHROUT
		txa
		jsr  c64.CHROUT
		pla
		jmp  c64.CHROUT
	}

; ---- print the byte in A in decimal form, without left padding 0s
print_byte_decimal      ; (A) -> (A?, X?, Y?)
	asm {
		jsr  byte2decimal
		pha
		tya
		cmp  #'0'
		beq  +
		jsr  c64.CHROUT
+		txa
		cmp  #'0'
		beq  +
		jsr  c64.CHROUT
+		pla
		jmp  c64.CHROUT
	}

; ---- print the byte in A in hex form
print_byte_hex          ; (A) -> (A?, X?, Y?)
	asm {
		jsr  byte2hex
		txa
		jsr  c64.CHROUT
		tya
		jmp  c64.CHROUT
	}

; ---- print the word in X/Y in decimal form, with left padding 0s (5 positions total)
print_word_decimal0      ; (XY) -> (A?, X?, Y?)
	asm {
		jsr  word2decimal
		lda  word2decimal_output
		jsr  c64.CHROUT
		lda  word2decimal_output+1
		jsr  c64.CHROUT
		lda  word2decimal_output+2
		jsr  c64.CHROUT
		lda  word2decimal_output+3
		jsr  c64.CHROUT
		lda  word2decimal_output+4
		jmp  c64.CHROUT
	}

; ---- print the word in X/Y in decimal form, without left padding 0s
print_word_decimal
	asm {
		jsr  word2decimal
		ldy  #0
		lda  word2decimal_output
		cmp  #'0'
		bne  _pr_decimal
		iny
		lda  word2decimal_output+1
		cmp  #'0'
		bne  _pr_decimal
		iny
		lda  word2decimal_output+2
		cmp  #'0'
		bne  _pr_decimal
		iny
		lda  word2decimal_output+3
		cmp  #'0'
		bne  _pr_decimal
		iny

_pr_decimal
                lda  word2decimal_output,y
		jsr  c64.CHROUT
		iny
		cpy  #5
		bcc  _pr_decimal
		rts
	}
}
